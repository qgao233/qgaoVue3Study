{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction https://staging-cn.vuejs.org/guide Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-08-08 18:44:32 "},"chapter1/":{"url":"chapter1/","title":"1 vue3入门","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 示例 1 俩特点 2 组件 3 单文件组件 4 组件书写风格 4.1 组合式 API 4.2 选项式 API 4.3 如何选用 5 quick start vue3入门 示例 test.vue export default { data() { return { count: 0 } } } Count is: button { font-weight: bold; } 1 俩特点 声明式渲染：Vue 基于标准 HTML 拓展了一套模板语法，使得我们可以声明式地描述最终输出的 HTML 和 JavaScript 状态之间的关系。 就是说：把各部分要用到的功能描述了一遍，由底层框架去调用程序员声明的功能实现来运行程序。 响应性：Vue 会自动跟踪 JavaScript 状态变化并在改变发生时响应式地更新 DOM。 说白了，一些定义的变量产生变化，就自动刷新局部页面。 2 组件 和react中的概念类似，这里写好这里可以用，也可以被其他地方导入，在其他地方使用。 3 单文件组件 使用一种类似 HTML 格式的文件来书写 Vue 组件，它被称为单文件组件 (也被称为 *.vue 文件，英文 Single-File Components，缩写为 SFC)。 说白了，Vue 的单文件组件(一个文件中) = 逻辑 (JavaScript) + 模板 (HTML) + 和样式 (CSS) 4 组件书写风格 4.1 组合式 API setup是一个标识，告诉 Vue 需要在编译时进行一些处理，让我们可以更简洁地使用组合式 API。比如， 中的导入和顶层变量/函数都能够在中直接使用。 import { ref, onMounted } from 'vue' // 响应式状态 const count = ref(0) // 用来修改状态、触发更新的函数 function increment() { count.value++ } // 生命周期钩子 onMounted(() => { console.log(`The initial count is ${count.value}.`) }) Count is: 4.2 选项式 API 类似面向对象语言，选项式 API 以“组件实例”的概念为中心 (即例子中的 this指向当前的组件实例)，基于组合式 API 的基础上实现。 export default { // data() 返回的属性将会成为响应式的状态 // 并且暴露在 `this` 上 data() { return { count: 0 } }, // methods 是一些用来更改状态与触发更新的函数 // 它们可以在模板中作为事件监听器绑定 methods: { increment() { this.count++ } }, // 生命周期钩子会在组件生命周期的各个不同阶段被调用 // 例如这个函数就会在组件挂载完成后被调用 mounted() { console.log(`The initial count is ${this.count}.`) } } Count is: 4.3 如何选用 当你不需要使用构建工具，或者打算主要在低复杂度的场景中使用 Vue，例如渐进增强的应用场景，推荐采用选项式 API。 当你打算用 Vue 构建完整的单页应用，推荐采用组合式 API + 单文件组件。 5 quick start 注意：在本地用vite构建vue项目时，使用npm init vue@latest会在当前目录创建你的项目，因此选好目录再使用该命令最好。 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-08-18 18:56:33 "},"chapter2/section1/":{"url":"chapter2/section1/","title":"2.1 创建一个 Vue 应用","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 应用实例 1.1 传入参数 2 根组件实例 2.1 传入参数 3 应用配置 4 多个应用实例 创建一个 Vue 应用 1 应用实例 createApp返回一个应用实例。 import { createApp } from 'vue' const app = createApp({ /* 根组件选项 */ }) 1.1 传入参数 传入的参数称之为这个应用实例的根组件， import { createApp } from 'vue' // 从一个单文件组件中导入根组件 import App from './App.vue' const app = createApp(App) 而在这个根组件内部import到的其他组件称之为子组件，如下： App (root component) ├─ TodoList │ └─ TodoItem │ ├─ TodoDeleteButton │ └─ TodoEditButton └─ TodoFooter ├─ TodoClearButton └─ TodoStatistics 2 根组件实例 应用实例通过调用 .mount() 方法后才被渲染出来，返回的称为根组件实例。 2.1 传入参数 传入参数称为容器，可以是： 一个实际的 DOM 元素 (标签) 或一个 CSS 选择器字符串 (id/class) app.mount('#app') createApp传入的根组件的内容将会被渲染在容器元素里面。而容器元素自己将不会被视为应用的一部分。 当在未采用构建流程的情况下使用 Vue 时，我们可以在挂载容器中直接书写根组件模板： import { createApp } from 'vue' const app = createApp({ data() { return { count: 0 } } }) app.mount('#app') 当根组件没有设置 template 选项时，Vue 将自动使用容器的 innerHTML 作为模板。 .mount() 方法应该始终在整个应用配置和资源注册(见3 应用配置)完成后被调用。 3 应用配置 应用实例会暴露一个 .config 对象允许我们配置一些应用级的选项，例如定义一个应用级的错误处理器，它将捕获所有由子组件上抛而未被处理的错误： app.config.errorHandler = (err) => { /* 处理错误 */ } 应用实例还提供了一些方法来注册应用范围内可用的资源，例如注册一个组件： app.component('TodoDeleteButton', TodoDeleteButton) 这使得 TodoDeleteButton 在应用的任何地方都是可用的。 4 多个应用实例 应用实例并不只限于一个。createApp API 允许你在同一个页面中创建多个共存的 Vue 应用，而且每个应用都拥有自己的用于配置和全局资源的作用域。 const app1 = createApp({ /* ... */ }) app1.mount('#container-1') const app2 = createApp({ /* ... */ }) app2.mount('#container-2') 如果你正在使用 Vue 来增强服务端渲染 HTML，并且只想要 Vue 去控制一个大型页面中特殊的一小部分，应避免将一个单独的 Vue 应用实例挂载到整个页面上，而是应该创建多个小的应用实例，将它们分别挂载到所需的元素上去。 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-08-08 20:51:33 "},"chapter2/section2/":{"url":"chapter2/section2/","title":"2.2 vue中的js表达式","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 往html中插值 2 JavaScript 表达式的使用场景 2.1 表达式使用限制 3 vue指令 3.1 动态参数 3.1.1 值限制 3.1.2 语法限制 4 修饰符 5 完整指令格式 vue中的js表达式 1 往html中插值 rawHtml = 'This should be red.' 1 插入文本：两个花括号之间本没有空格，因为gitbook的原因所以空的 Using text interpolation: { { rawHtml } } 会被替换为 Using text interpolation: This should be red. 2 插入html，使用v-html属性： 会被替换为 This should be red. 3 映射标签的属性id到自定义的字段dynamicId上： 若dynamicId为null 或 undefined，属性id将会从渲染的元素上移除， 可简写为： 4 映射标签的布尔属性disabled到自定义的字段isButtonDisabled上： Button 当 isButtonDisabled 为真值或一个空字符串 (即 ) 时，元素会包含这个 disabled attribute。 而当其为其他假值时 attribute 将被忽略。 5 映射JavaScript 对象到标签的属性上 data() { return { objectOfAttrs: { id: 'container', class: 'wrapper' } } } 2 JavaScript 表达式的使用场景 在Vue 模板内，可以在： 在文本插值中 【双大括号内】 在任何 Vue 指令 (以 v- 开头的特殊属性) 的值中【v-**=\"值\"】 { { number + 1 } } { { ok ? 'YES' : 'NO' } } { { message.split('').reverse().join('') } } 2.1 表达式使用限制 一、单一表达式 每个绑定仅支持单一表达式，判断方法：是否可以合法地写在 return 后面。 因此表达式也可写成调用其他组件暴露的方法： { { formatDate(date) } } 绑定在表达式中的方法在组件每次更新时都会被重新调用，因此不应该产生任何副作用，比如改变数据或触发异步操作。 二、全局对象 表达式将被沙盒化，仅能够访问到有限的全局对象列表。该列表中会暴露常用的内置全局对象，比如 Math 和 Date。 而用户附加在 window 上的属性没有显式包含在列表中的全局对象将不能在模板内表达式中，只有在 app.config.globalProperties 上显式地添加，才能访问到。 3 vue指令 指令通常期待一个表达式，任务是在其表达式的值变化时响应式地更新 DOM。 v-for、v-on 和 v-slot则不期待表达式 1 v-if 指令会基于表达式 seen 的值的真假来移除/插入该 元素。 Now you see me 2 v-on监听 DOM 事件 ... 可简写为： ... 3.1 动态参数 指令的参数，写在方括号内，可使用js表达式 ... 可简写为： 通过计算，eventName = \"click\",即当点击时，会调用doSomething() 3.1.1 值限制 动态参数中表达式的值应当是一个字符串，或者是 null。特殊值 null 意为显式移除该绑定。其他非字符串的值会触发警告。 3.1.2 语法限制 一、空格和引号 两者在 HTML 标签的属性名称中都是不合法的。 因此 ... ，即使'foo' + bar的结果是一个合法的字符串，但因为空格和单引号的存在都会产生警告，可用计算属性替换复杂的表达式。 二、大写 如果你的组件拥有 “someAttr” 属性： const someAttr = 'ddd'; 且表达式写为： ... 浏览器会强制将表达式的someAttr替换为 someattr(全部转小写)，最后这段代码将不会工作。 而单文件组件内的模板不受此限制。 4 修饰符 以点开头的特殊后缀，如 .prevent 修饰符会告知 v-on 指令对触发的事件调用 event.preventDefault()： ... 5 完整指令格式 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-08-12 17:22:36 "},"chapter2/section3/":{"url":"chapter2/section3/","title":"2.3 如何使页面动态变化","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 声明状态变量 1.1 注意 2 声明方法 3 DOM 更新时机 4 默认深层响应式 5 调用某个函数（而这个函数自身内部有状态） 如何使页面动态变化 响应式状态：当一个变量通过计算发生值的变化时称为状态的变化，并且页面引用该值的位置会及时得到响应进行改变。 1 声明状态变量 选用选项式 API 时，会用 data 选项来声明组件的响应式状态。 data() {}, 此选项的值应为返回一个对象的函数。 data() { return 函数【该函数返回一个对象】 }, Vue 将在创建新组件实例的时候调用此函数，并将函数返回的对象用响应式系统进行包装。此对象的所有顶层属性都会被代理到组件实例 (即方法和生命周期钩子中的 this) 上。如下： export default { data() { return { //直接返回对象也行 count: 1 } }, // `mounted` 是生命周期钩子，之后我们会讲到 mounted() { // `this` 指向当前组件实例 console.log(this.count) // => 1 // 数据属性也可以被更改 this.count = 2 } } 这些实例上的属性仅在实例首次创建时被添加，若所需的值还未准备好，在必要时也可以使用 null、undefined 或者其他一些值占位。 不在 data 上定义的组件实例后添加的新属性将无法触发响应式更新。 状态变量中不能使用 $ 或 _ 因为Vue 在组件实例上暴露的内置 API 使用 $ 作为前缀。它同时也为内部属性保留 _ 前缀。 1.1 注意 状态变量基于js代理实现响应式。 说白了，这些所谓的状态变量会被js监控，值变了就通过js修改，页面中的值自然会发生变化。 export default { data() { return { someObject: {} } }, mounted() { const newObject = {} this.someObject = newObject //两者值一样，但someObject还是状态变量，newObject只是个普通 console.log(newObject === this.someObject) // false } } 2 声明方法 methods 选项是一个包含所有方法的对象： export default { data() { return { count: 0 } }, methods: { increment() { this.count++ }, { // 反例：箭头函数无法访问此处的 `this`! } --> }, mounted() { // 在其他方法或是生命周期中也可以调用方法 this.increment() } } Vue 自动为 methods 中的方法绑定了永远指向组件实例的 this。这确保了方法在作为事件监听器或回调函数时始终保持正确的 this。不应该在定义 methods 时使用箭头函数，因为箭头函数没有自己的 this 上下文。 和组件实例上的其他属性一样，方法也可以在模板上被访问。在模板中它们常常被用作事件监听器： 3 DOM 更新时机 当你更改响应式状态后，DOM 也会自动更新。然而，你得注意 DOM 的更新并不是同步的。相反，Vue 将缓冲它们直到更新周期的 “下个时机” 以确保无论你进行了多少次声明更改，每个组件都只需要更新一次。 可以使用 nextTick() 这个全局 API访问到状态改变后的 DOM： import { nextTick } from 'vue' export default { methods: { increment() { this.count++ nextTick(() => { // 访问更新后的 DOM }) } } } 4 默认深层响应式 即使在更改深层次的对象或数组，改动也能被检测到。 export default { data() { return { obj: { nested: { count: 0 }, arr: ['foo', 'bar'] } } }, methods: { mutateDeeply() { // 以下都会按照期望工作 this.obj.nested.count++ this.obj.arr.push('baz') } } } 也可以直接创建一个浅层响应式对象。它们仅在顶层具有响应性，一般仅在某些特殊场景中需要。 5 调用某个函数（而这个函数自身内部有状态） 在某些情况下，我们可能需要动态地创建一个方法函数，比如创建一个预置防抖的事件处理器： import { debounce } from 'lodash-es' export default { methods: { // 使用 Lodash 的防抖函数 click: debounce(function () { // ... 对点击的响应 ... }, 500) } } 不过这种方法对于被重用的组件来说是有问题的，因为这个预置防抖的函数是 有状态的：它在运行时维护着一个内部状态。如果多个组件实例都共享这同一个预置防抖的函数，那么它们之间将会互相影响。 要保持每个组件实例的防抖函数都彼此独立，我们可以改为在 created 生命周期钩子中创建这个预置防抖的函数： export default { created() { // 每个实例都有了自己的预置防抖的处理函数 this.debouncedClick = _.debounce(this.click, 500) }, unmounted() { // 最好是在组件卸载时 // 清除掉防抖计时器 this.debouncedClick.cancel() }, methods: { click() { // ... 对点击的响应 ... } } } Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-08-10 17:58:38 "},"chapter2/section4/":{"url":"chapter2/section4/","title":"2.4 可重用的计算","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 computed 2 computed vs methods 3 更改计算属性 4 注意 可重用的计算 1 computed export default { data() { return { author: { name: 'John Doe', books: [ 'Vue 2 - Advanced Guide', 'Vue 3 - Basic Guide', 'Vue 4 - The Mystery' ] } } } } { { author.books.length > 0 ? 'Yes' : 'No' } } 如果在模板中需要不止一次这样的计算，便显得代码臃肿。 推荐使用计算属性computed来描述依赖响应式状态的复杂逻辑 export default { data() { return { author: { name: 'John Doe', books: [ 'Vue 2 - Advanced Guide', 'Vue 3 - Basic Guide', 'Vue 4 - The Mystery' ] } } }, computed: { // 一个计算属性的 getter publishedBooksMessage() { // `this` 指向当前组件实例 return this.author.books.length > 0 ? 'Yes' : 'No' } } } { { publishedBooksMessage } } Vue 会检测到 this.publishedBooksMessage 依赖于 this.author.books， 所以当 this.author.books 改变时，任何依赖于 this.publishedBooksMessage 的绑定都将同时更新。 2 computed vs methods // 组件中 methods: { calculateBooksMessage() { return this.author.books.length > 0 ? 'Yes' : 'No' } } { { calculateBooksMessage() } } 两者的不同之处在于计算属性值会基于其响应式依赖被缓存。 一个计算属性仅会在其响应式依赖更新时才重新计算。这意味着只要 author.books 不改变，无论多少次访问 publishedBooksMessage 都会立即返回先前的计算结果，而不用重复执行 getter 函数。 错误使用案例 computed: { now() { return Date.now() //Date.now() 并不是一个响应式依赖，因此计算属性now永远不会更新 } } 3 更改计算属性 在外部手动修改计算属性，而不是通过计算函数得出结果，必须得重写getter、setter方法： export default { data() { return { firstName: 'John', lastName: 'Doe' } }, computed: { fullName: { // getter get() { return this.firstName + ' ' + this.lastName }, // setter set(newValue) { // 注意：我们这里使用的是解构赋值语法 [this.firstName, this.lastName] = newValue.split(' ') } } } } this.fullName = 'John Doe' //修改成功，因为setter调用时，实际上还是改的状态变量，从而导致依赖它两个的计算变量得到更新。 总的来说，虽然可以更改，但其实没有必要。 4 注意 不要在计算函数中产生异步请求或者更改 DOM等副作用，有专门讲的监听器：根据其他响应式状态的变更来主动创建副作用。 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-08-17 17:44:39 "},"chapter2/section5/":{"url":"chapter2/section5/","title":"2.5 v-bind的特殊增强","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 针对class 1.1 与class并存 1.2 引用对象 1.3 引用计算属性（常用） 1.4 引用数组 1.5 在组件上使用class的情况 1.5.1 一个根节点 1.5.1 多个根节点 2 针对style 2.1 引用对象（常用） 2.2 引用计算属性 2.3 引用数组 2.4 自动前缀 2.5 样式多值 v-bind的特殊增强 Vue 专门为 class 和 style 的 v-bind 用法提供了特殊的功能增强：除了字符串外，表达式的值也可以是对象或数组。 1 针对class 给v-bind:class传递一个对象，判断是否class=\"active\"： 可见active是否出现，要依赖于状态变量isActive的值。 1.1 与class并存 由于class的值可以同时有多个，因此vue也支持和一般的 class属性共存。 data() { return { isActive: true, hasError: false } } 渲染后便是： //因为hasError为false，所以text-danger没出现 1.2 引用对象 data() { return { classObject: { active: true, 'text-danger': false } } } 结果一样。 1.3 引用计算属性（常用） data() { return { isActive: true, error: null } }, computed: { classObject() { return { active: this.isActive && !this.error, 'text-danger': this.error && this.error.type === 'fatal' } } } 1.4 引用数组 data() { return { activeClass: 'active', errorClass: 'text-danger' } } 渲染后是： 还可以使用三目表达式： 可以直接换成： 1.5 在组件上使用class的情况 一个组件被写好后，通常会被其它组件import后进行使用，那么在被外部使用时会出现两种情况： 组件内部只有一个根节点 组件内部有多个根节点 1.5.1 一个根节点 声明了一个组件名叫 MyComponent，内部实现的template如下： Hi! 被外部使用时添加一些 class： 此时这个class的值只会被绑定到唯一的根节点上： Hi 1.5.1 多个根节点 在实现内部使用$attrs获得上层传入的属性，然后根据情况选择在何处使用： Hi! This is a child component 被外部使用时添加一些 class： 此时这个class的值传到内部后： Hi! This is a child component 2 针对style data() { return { activeColor: 'red', fontSize: 30 } } CSS的字段支持： 驼峰法（camelCase）【推荐使用】 短横线隔开式 （kebab-cased）【对应其 CSS 中的实际名称】 2.1 引用对象（常用） data() { return { styleObject: { color: 'red', fontSize: '13px' } } } 2.2 引用计算属性 2.3 引用数组 2.4 自动前缀 当你在 :style 中使用了需要浏览器特殊前缀的 CSS 属性时，Vue 会自动为他们加上相应的前缀。Vue 是在运行时检查该属性是否支持在当前浏览器中使用。如果浏览器不支持某个属性，那么将测试加上各个浏览器特殊前缀，以找到哪一个是被支持的。 2.5 样式多值 你可以对一个样式属性提供多个 (不同前缀的) 值，举例来说： 数组仅会渲染浏览器支持的最后一个值。在这个示例中，在支持不需要特别前缀的浏览器中都会渲染为 display: flex。 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-08-12 18:19:18 "},"chapter2/section6/":{"url":"chapter2/section6/","title":"2.6 v-if介绍","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 v-if · v-else-if · v-else 1.1 上的 v-if 2 v-show 3 v-if vs v-show 4 v-if 和 v-for v-if介绍 1 v-if · v-else-if · v-else 元素必须在同级，并且是紧跟上一元素。 这三个在只有当条件为true时，才会渲染元素，也就是dom上才会有这个元素，否则就没有。 Toggle Toggle A B C Not A/B/C 1.1 上的 v-if 因为 v-if 是一个指令，他必须依附于某个元素。但如果我们想要切换不止一个元素呢？在这种情况下我们可以在一个 元素上使用 v-if，这只是一个不可见的包装器元素，最后渲染的结果并不会包含这个 元素。 Title Paragraph 1 Paragraph 2 v-else 和 v-else-if 也可以在 上使用。 思考：可否像这样： Title Paragraph 1 Paragraph 2 2 v-show v-show 仅切换了该元素上名为 display 的 CSS 属性，并且会在 DOM 渲染中保留该元素。 v-show 不支持在 元素上使用，也不能和 v-else 搭配使用。 Hello! 3 v-if vs v-show v-if 是惰性的：如果在初次渲染时条件值为 false，则不会做任何事。条件区块只有当条件首次变为 true 时才被渲染。 v-if 是“真实的”按条件渲染，因为它确保了在切换时，条件区块内的事件监听器和子组件都会被销毁与重建。 v-show 简单许多，元素无论初始条件如何，始终会被渲染，只有 CSS display 属性会被切换。 总的来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要频繁切换，则使用 v-show 较好；如果在运行时绑定条件很少改变，则 v-if 会更合适。 4 v-if 和 v-for 当 v-if 和 v-for 同时存在于一个元素上的时候，v-if 会首先被执行。 同时使用 v-if 和 v-for 是不推荐的，因为这样二者的优先级不明显。 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-08-15 18:01:06 "},"chapter2/section7/":{"url":"chapter2/section7/","title":"2.7 v-for介绍","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 遍历数组 1.1 js模拟vue的实现效果 1.2 遍历时使用解构 1.3 of 替代 in 2 遍历对象 3 v-for的循环次数 4 上的 v-for 5 v-for 与 v-if 6 v-for渲染后又发生更新 7 组件上使用 v-for 7.1 渲染结果 8 数组变化时的渲染 8.1 变更方法 8.2 非变更方法 8.3 利用计算属性 v-for介绍 1 遍历数组 data() { return { parentMessage: 'Parent', items: [{ message: 'Foo' }, { message: 'Bar' }] } } //当前项的位置索引index参数为可选参数 { { parentMessage } } - { { index } } - { { item.message } } 渲染后： Parent - 0 - Foo Parent - 1 - Bar 1.1 js模拟vue的实现效果 const parentMessage = 'Parent' const items = [ /* ... */ ] items.forEach((item, index) => { // 可以访问外层的 `parentMessage` // 而 `item` 和 `index` 只在这个作用域可用 console.log(parentMessage, item.message, index) }) 1.2 遍历时使用解构 //从对象里解构出字段 { { message } } { { message } } { { index } } 1.3 of 替代 in JavaScript 的迭代器语法用 of 2 遍历对象 export default { data() { return { myObject: { title: 'How to do lists in Vue', author: 'Jane Doe', publishedAt: '2016-04-10' } } } } { { index } }. { { key } }: { { value } } 渲染后： 0. title: How to do lists in Vue 1. author: Jane Doe 2. publishedAt: 2016-04-10 3 v-for的循环次数 { { n } } 注意此处 n 的初值是从 1 开始而非 0，即n = [1,10]。 4 上的 v-for 与模板上的 v-if 类似，你也可以在 标签上使用 v-for 来渲染一个包含多个元素的块。例如： { { item.msg } } 5 v-for 与 v-if 在上一section的最后一个小节讲过， 当它们同时存在于一个节点上时，v-if 比 v-for 的优先级更高。这意味着 v-if 的条件将无法访问到 v-for 作用域内定义的变量别名： { { todo.name } } 在外新包装一层 再在其上使用 v-for 可以解决这个问题 (这也更加明显易读)： { { todo.name } } 6 v-for渲染后又发生更新 v-for 渲染的元素列表更新的默认模式为：当数据项的顺序改变时，Vue 不会随之移动 DOM 元素的顺序，而是就地更新每个元素内的值，但只适用于列表渲染输出的结果不依赖子组件状态或者临时 DOM 状态 (例如表单输入值) 的情况。 上面仅供了解，如果发生需要移动dom元素的场景，我们使用v-for，通常需要绑定一个key跟踪每个节点的标识： //使用的v-bind:key 当你使用 时，key 应该被放置在这个 容器上： { { todo.name } } key 绑定的值期望是一个基础类型的值，例如字符串或 number 类型。不要用对象作为 v-for 的 key。 7 组件上使用 v-for import TodoItem from './TodoItem.vue' export default { components: { TodoItem }, data() { return { todos: [ { id: 1, title: 'Do the dishes' }, { id: 2, title: 'Take out the trash' }, { id: 3, title: 'Mow the lawn' } ], } } } 下面是TodoItem.vue export default { props: ['title'], } { { title } } 7.1 渲染结果 Do the dishes Take out the trash Mow the lawn 8 数组变化时的渲染 8.1 变更方法 对原数组进行修改。 push() pop() shift() unshift() splice() sort() reverse() 8.2 非变更方法 原数组不变，返回一个新数组。 filter() concat() slice() 例： this.items = this.items.filter((item) => item.message.match(/Foo/)) 8.3 利用计算属性 有时，我们希望显示数组经过过滤或排序后的内容，而不实际变更或重置原始数据。 data() { return { sets: [[ 1, 2, 3, 4, 5 ], [6, 7, 8, 9, 10]] } }, methods: { even(numbers) { return numbers.filter(number => number % 2 === 0) } } { { n } } 在计算属性中使用 reverse() 和 sort() 的时候务必小心！这两个方法将变更原始数组，计算函数中不应该这么做。请在调用这些方法之前创建一个原数组的副本： //return numbers.reverse() return [...numbers].reverse() Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-08-14 18:25:18 "},"chapter2/section8/":{"url":"chapter2/section8/","title":"2.8 事件处理","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 事件处理器的分类 1.1 区分两种事件处理器 2 内联事件处理器中访问event参数 3 修饰符 3.1 事件修饰符 3.2 按键修饰符 3.2.1 vue提供的默认别名 3.3 鼠标或键盘事件监听器（系统修饰符） 3.4 .exact 修饰符 3.5 鼠标按键修饰符 事件处理 可以使用 v-on 指令 (简写为 @) 来监听 DOM 事件（click之类的）。 1 事件处理器的分类 内联事件处理器：直接在双引号里写js语句。 Add 1 Count is: { { count } } methods: { say(message) { alert(message) } } Say hello 方法事件处理器：一个指向组件上定义的方法的属性名或是路径。 methods: { greet(event) { // 方法中的 `this` 指向当前活跃的组件实例 alert(`Hello ${this.name}!`) // `event` 是 DOM 原生事件 if (event) { alert(event.target.tagName) //访问到该 DOM 元素。 } } } Greet 从例子可以看出，它只是写了一个方法名字，而不像js调用方法，需要在后面加括号。 1.1 区分两种事件处理器 方法事件处理器：foo、foo.bar 和 foo['bar'] ， 内联事件处理器：foo() 和 count++。 2 内联事件处理器中访问event参数 向处理器方法传入一个特殊的 $event 变量， 或者使用内联箭头函数。 methods: { warn(message, event) { // 这里可以访问 DOM 原生事件 if (event) { event.preventDefault() } alert(message) } } Submit warn('Form cannot be submitted yet.', event)\"> Submit 3 修饰符 修饰符是用 . 表示的指令后缀。 3.1 事件修饰符 在处理事件时调用 event.preventDefault() 或 event.stopPropagation() 是很常见的。尽管我们可以直接在方法内调用，但如果方法能更专注于数据逻辑而不用去处理 DOM 事件的细节会更好。 为解决这一问题，Vue 为 v-on 提供了事件修饰符。包含以下这些： .stop .prevent .self .capture .once .passive ... 使用修饰符时需要注意调用顺序，因为相关代码是以相同的顺序生成的。因此使用 @click.prevent.self 会阻止元素及其子元素的所有点击事件的默认行为而 @click.self.prevent 则只会阻止对元素本身的点击事件的默认行为。 .capture、.once 和 .passive 修饰符与原生 addEventListener 事件相对应： ... ... .passive 修饰符一般用于触摸事件的监听器，可以用来改善移动端设备的滚屏性能。 请勿同时使用 .passive 和 .prevent，因为 .passive 已经向浏览器表明了你不想阻止事件的默认行为。如果你这么做了，则 .prevent 会被忽略，并且浏览器会抛出警告。 3.2 按键修饰符 在监听键盘事件时，我们经常需要检查特定的按键。Vue 允许在 v-on 或 @ 监听按键事件时添加按键修饰符。 你可以直接使用 KeyboardEvent.key 暴露的按键名称作为修饰符，但需要转为 kebab-case 形式。 在上面的例子中，仅会在 $event.key 为 'PageDown' 时调用事件处理。 3.2.1 vue提供的默认别名 Vue 为一些常用的按键提供了别名： .enter .tab .delete (捕获“Delete”和“Backspace”两个按键) .esc .space .up .down .left .right 3.3 鼠标或键盘事件监听器（系统修饰符） .ctrl .alt .shift .meta 在 Mac 键盘上，meta 是 Command 键 (⌘)。在 Windows 键盘上，meta 键是 Windows 键 (⊞)。在 Sun 微机系统键盘上，meta 是钻石键 (◆)。在某些键盘上，特别是 MIT 和 Lisp 机器的键盘及其后代版本的键盘，如 Knight 键盘，space-cadet 键盘，meta 都被标记为“META”。在 Symbolics 键盘上，meta 也被标识为“META”或“Meta”。 举例来说： Do something 请注意，系统按键修饰符和常规按键不同。与 keyup 事件一起使用时，该按键必须在事件发出时处于按下状态。换句话说，keyup.ctrl 只会在你仍然按住 ctrl 但松开了另一个键时被触发。若你单独松开 ctrl 键将不会触发。 3.4 .exact 修饰符 .exact 修饰符允许控制触发一个事件所需的确定组合的系统按键修饰符。 A A A 3.5 鼠标按键修饰符 .left .right .middle 这些修饰符将处理程序限定为由特定鼠标按键触发的事件。 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-08-15 17:55:52 "},"chapter2/section9/":{"url":"chapter2/section9/","title":"2.9 表单输入绑定","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 v-model（静态的字符串） 1.1 textarea 1.2 checkbox 1.3 radio 1.4 select 2 v-model（动态数据） 2.1 checkbox 2.2 radio 2.3 select 3 修饰符 3.1 .lazy 3.2 .number 3.3 .trim 4 组件上的 v-model 表单输入绑定 在前端处理表单时，我们常常需要将表单输入框的内容同步给 JavaScript 中相应的变量。 手动连接值绑定和更改事件监听器可能会很麻烦： text = event.target.value\"> 1 v-model（静态的字符串） v-model 指令帮我们简化了这一步骤： v-model 支持： 和 ：绑定 value 属性并侦听 input 事件； ：绑定 checked 属性并侦听 change 事件； ：绑定 value 属性并侦听 change 事件： 使用v-model 会忽略任何表单元素上初始的 value、checked 或 selected 属性。 1.1 textarea { { text } } 1.2 checkbox { { checked } } 将多个复选框绑定到同一个数组或集合的值： export default { data() { return { checkedNames: [] } } } Checked names: { { checkedNames } } Jack John Mike 1.3 radio Picked: { { picked } } One Two 1.4 select Selected: { { selected } } Please select one A B C 如果 v-model 表达式的初始值不匹配任何一个选择项， 元素会渲染成一个“未选择”的状态。在 iOS 上，这将导致用户无法选择第一项，因为 iOS 在这种情况下不会触发一个 change 事件。因此，我们建议提供一个空值的禁用选项，如上面的例子所示。 多选 (值绑定到一个数组)： Selected: { { selected } } A B C v-for 动态渲染选项 export default { data() { return { selected: 'A', options: [ { text: 'One', value: 'A' }, { text: 'Two', value: 'B' }, { text: 'Three', value: 'C' } ] } } } { { option.text } } Selected: { { selected } } 2 v-model（动态数据） 2.1 checkbox true-value 和 false-value 是 Vue 特有的属性，仅支持和 v-model 配套使用。这里 toggle 属性的值会在选中时被设为 'yes'，取消选择时设为 'no'。你同样可以通过 v-bind 将其绑定为其他动态值： true-value 和 false-value attributes 不会影响 value attribute，因为浏览器在表单提交时，并不会包含未选择的复选框。如果要保证这两个值 (例如：“yes”和“no”) 的其中之一被表单提交，请使用单选按钮作为替代。 2.2 radio pick 会在第一个按钮选中时被设为 first，在第二个按钮选中时被设为 second。 2.3 select 123 v-model 同样也支持非字符串类型的值绑定！在上面这个例子中，当某个选项被选中，selected 会被设为该对象字面量值 { number: 123 }。 3 修饰符 3.1 .lazy 默认情况下，v-model 会在每次 input 事件后更新数据 (IME 拼字阶段的状态例外)。你可以添加 lazy 修饰符来改为在每次 change 事件后更新数据： input输入框的onchange事件，要在 input 失去焦点的时候才会触发。 3.2 .number 如果你想让用户输入自动转换为数字，你可以在 v-model 后添加 .number 修饰符来管理输入： 如果该值无法被 parseFloat() 处理，那么将返回原始值。 number 修饰符会在输入框有 type=\"number\" 时自动启用。 3.3 .trim 如果你想要默认自动去除用户输入内容中两端的空格，你可以在 v-model 后添加 .trim 修饰符： 4 组件上的 v-model Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-08-16 20:25:39 "},"chapter2/section10/":{"url":"chapter2/section10/","title":"2.10 生命周期与钩子","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 注册周期钩子 2 生命周期 生命周期与钩子 每个 Vue 组件实例在创建时都需要经历一系列的初始化步骤，比如设置好数据侦听，编译模板，挂载实例到 DOM，以及在数据改变时更新 DOM。 在此过程中，它也会运行被称为生命周期钩子的函数，让开发者有机会在特定阶段运行自己的代码。 1 注册周期钩子 举例来说，mounted 钩子可以用来在组件完成初始渲染并创建 DOM 节点后运行代码： export default { mounted() { console.log(`the component is now mounted.`) } } 还有其他一些钩子，会在实例生命周期的不同阶段被调用，最常用的是 mounted、updated 和 unmounted。 所有生命周期钩子函数的 this 上下文都会自动指向当前调用它的组件实例。 注意：避免用箭头函数来定义生命周期钩子，因为如果这样的话你将无法在函数中通过 this 获取组件实例。 2 生命周期 生命周期钩子 API 索引 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-08-17 17:43:18 "},"chapter2/section11/":{"url":"chapter2/section11/","title":"2.11 状态变量侦听器","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 简单介绍 2 深层侦听器 3 即时回调的侦听器 4 回调的触发时机 5 this.$watch() 6 停止侦听器 状态变量侦听器 1 简单介绍 我们知道计算属性允许我们声明性地计算衍生值。 然而在有些情况下，我们需要在状态变化时执行一些“副作用”，例如： 更改 DOM， 或是根据异步操作的结果去修改另一处的状态。 export default { data() { return { question: '', answer: 'Questions usually contain a question mark. ;-)' } }, watch: { // 此处的方法名要与状态变量一致 // 每当 状态变量question 改变时，这个函数就会执行 question(newQuestion, oldQuestion) { if (newQuestion.indexOf('?') > -1) { this.getAnswer() } } }, methods: { async getAnswer() { this.answer = 'Thinking...' try { const res = await fetch('https://yesno.wtf/api') this.answer = (await res.json()).answer } catch (error) { this.answer = 'Error! Could not reach the API. ' + error } } } } Ask a yes/no question: { { answer } } watch 选项也支持把键设置成用 . 分隔的路径： export default { watch: { // 注意：只能是简单的路径，不支持表达式。 'some.nested.key'(newValue) { // ... } } } 2 深层侦听器 watch 默认是浅层的：被侦听的属性，仅在被赋新值时，才会触发回调函数——而嵌套属性的变化不会触发。如果想侦听所有嵌套的变更，你需要深层侦听器： export default { watch: { someObject: { handler(newValue, oldValue) { // 注意：在嵌套的变更中， // 只要没有替换对象本身， // 那么这里的 `newValue` 和 `oldValue` 相同 }, deep: true } } } 深度侦听需要遍历被侦听对象中的所有嵌套的属性，当用于大型数据结构时，开销很大。因此请只在必要时才使用它，并且要留意性能。 3 即时回调的侦听器 watch 默认是懒执行的：仅当数据源变化时，才会执行回调。但在某些场景中，我们希望在创建侦听器时，立即执行一遍回调。 举例来说，我们想请求一些初始数据，然后在相关状态更改时重新请求数据。 我们可以用一个对象来声明侦听器，这个对象有 handler 方法和 immediate: true 选项，这样便能强制回调函数立即执行： export default { // ... watch: { question: { handler(newQuestion) { // 在组件实例创建时会立即调用 }, // 强制立即执行回调 immediate: true } } // ... } 4 回调的触发时机 默认优先性：用户创建的侦听器回调 > Vue 组件更新时机 如果想在侦听器回调中能访问被 Vue 更新之后的DOM，你需要指明 flush: 'post' 选项： export default { // ... watch: { key: { handler() {}, flush: 'post' } } } 5 this.$watch() 可以使用组件实例的 $watch() 方法来命令式地创建一个侦听器： export default { created() { this.$watch('question', (newQuestion) => { // ... }) } } 如果要在特定条件下设置一个侦听器，或者只侦听响应用户交互的内容，这方法很有用。它还允许你提前停止该侦听器。 6 停止侦听器 用 watch 选项或者 $watch() 实例方法声明的侦听器，会在宿主组件卸载时自动停止。 在少数情况下，你的确需要在组件卸载之前就停止一个侦听器，这时可以调用 $watch() API 返回的函数： const unwatch = this.$watch('foo', callback) // ...当该侦听器不再需要时 unwatch() Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-08-17 18:03:25 "},"chapter2/section12/":{"url":"chapter2/section12/","title":"2.12 template 内的ref","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 使用ref 2 v-for中使用ref 3 ref作为函数入参 4 组件上使用ref 4.1 限制对子组件实例的访问 内的ref 可以称为模板引用。 1 使用ref 某些情况下，我们仍然需要直接访问底层 DOM 元素。 ref 是一个特殊的属性，和 v-for 章节中提到的 key 类似。它允许我们在一个特定的 DOM 元素或子组件实例被挂载结束后，它的直接引用都会被暴露在 this.$refs 之上： export default { mounted() { this.$refs.input.focus() //在组件挂载后将焦点设置到一个 input 元素上 } } 注意，只可以在组件挂载后才能访问模板引用。如果你想在模板中的表达式上访问 $refs.input，在初次渲染时会是 null。这是因为在初次渲染前这个元素还不存在 2 v-for中使用ref 当在 v-for 中使用模板引用时，相应的引用中包含的值是一个数组： export default { data() { return { list: [ /* ... */ ] } }, mounted() { console.log(this.$refs.items) } } { { item } } 注意，ref 数组并不保证与源数组相同的顺序。 3 ref作为函数入参 ref 还可以绑定为一个函数，会在每次组件更新时都被调用。该函数会收到元素引用作为其第一个参数： { /* 将 el 赋值给一个数据属性或 ref 变量 */ }\"> 注意我们这里需要使用动态的 :ref 绑定才能够传入一个函数。当绑定的元素被卸载时，函数也会被调用一次，此时的 el 参数会是 null。你当然也可以绑定一个组件方法而不是内联函数。 4 组件上使用ref ref被用在子组件上时，这种情况下引用中获得的值的是组件实例： import Child from './Child.vue' export default { components: { Child }, mounted() { // this.$refs.child 是 组件的实例 } } 如果一个子组件使用的是选项式 API ，被引用的组件实例和该子组件的 this 完全一致，这意味着父组件对子组件的每一个属性和方法都有完全的访问权。 这使得在父组件和子组件之间创建紧密耦合的实现细节变得很容易，当然也因此，应该只在绝对需要时才使用组件引用。 大多数情况下，你应该首先使用标准的 props 和 emit 接口来实现父子组件交互。 4.1 限制对子组件实例的访问 expose 选项可以用于限制对子组件实例的访问： export default { expose: ['publicData', 'publicMethod'], data() { return { publicData: 'foo', privateData: 'bar' } }, methods: { publicMethod() { /* ... */ }, privateMethod() { /* ... */ } } } 在上面这个例子中，父组件通过模板引用访问到子组件实例后，仅能访问 publicData 和 publicMethod。 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-08-18 17:33:48 "},"chapter2/section13/":{"url":"chapter2/section13/","title":"2.13 何为组件","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 定义组件 2 使用组件 3 传递属性 props（父组件与子组件交互） 4 监听事件（子组件与父组件交互） 5 占位符 6 动态组件 7 直接在DOM中写模板 7.1 大小写区分 7.2 闭合标签 7.3 元素位置限制 何为组件 组件允许我们将 UI 划分为独立的、可重用的部分，并且可以对每个部分进行单独的思考。 Vue 实现了自己的组件模型，使我们可以在每个组件内封装自定义内容与逻辑。 1 定义组件 单文件组件 (SFC)：将 Vue 组件定义在一个单独的 .vue 文件中。 export default { data() { return { count: 0 } } } You clicked me times. 内联写法：这里的template是一个内联的 JavaScript 字符串，Vue 将会在运行时编译它。 export default { data() { return { count: 0 } }, template: ` You clicked me times. ` } 你也可以使用 ID 选择器来指向一个元素 (通常是原生的 元素)，Vue 将会使用其内容作为模板来源。(这句话没懂) 2 使用组件 这里仅介绍单文件的使用。 两种不同写法的使用方法 import ButtonCounter from './ButtonCounter.vue' //在父组件中导入 export default { components: { ButtonCounter //为了暴露给父组件的模板使用，需要注册，注册时的名字作为模板中的标签名。 } } Here is a child component! 组件可以重复使用，每使用一次，就创建一个新的实例（参考类与对象的关系）： Here is a child component! 在单文件组件中，推荐为子组件使用 PascalCase （大驼峰写法）的标签名，以此来和原生的 HTML 元素作区分。虽然原生 HTML 标签名是不区分大小写的，但 Vue 单文件组件是可以在编译中区分大小写的。我们也可以使用 /> 来关闭一个标签。 如果你是直接在 DOM 中书写模板 (例如原生 元素的内容)，模板的编译需要遵从浏览器中 HTML 的解析行为。在这种情况下，你应该需要使用 kebab-case 形式并显式地关闭这些组件的标签。 3 传递属性 props（父组件与子组件交互） 表示博客文章的组件： export default { props: ['title'] //注册title } 该属性的值 (title) 可以像其他组件属性一样，在模板和组件的 this 上下文中访问。 当一个 prop 在子组件内被注册后，可以在父组件中如此使用： 在实际应用中不会像上面这样写，而是如下： export default { // ... data() { return { posts: [ { id: 1, title: 'My journey with Vue' }, { id: 2, title: 'Blogging with Vue' }, { id: 3, title: 'Why Vue is so fun' } ] } } } 4 监听事件（子组件与父组件交互） 要在此处实现 A11y 的需求，将博客文章的文字能够放大，而页面的其余部分仍使用默认字号。 A11y：Accessibility，可访问性的，11代表“A”和“Y”之间的11个字母。它指的是每个人（包括残障人士）对软件的可访问性。 首先在父组件中，我们可以添加一个 postFontSize 数据属性来控制所有博客文章的字体大小： data() { return { posts: [ /* ... */ ], postFontSize: 1 } } 然后在子组件中添加一个按钮： --> Enlarge text 我们想要点击这个按钮来告诉父组件它应该放大所有博客文章的文字。 此时，父组件可以通过 v-on 或 @ 来选择性地监听子组件上抛的事件，就像监听原生 DOM 事件那样： 子组件可以通过调用内置的 $emit 方法，通过传入事件名称来抛出一个事件： export default { props: ['title'], emits: ['enlarge-text'] } Enlarge text emits声明了一个组件可能触发的所有事件，还可以对事件的参数进行验证。同时，这还可以让 Vue 避免将它们作为原生事件监听器隐式地应用于子组件的根元素。 5 占位符 父组件使用引用的组件时： Something bad happened. 子组件中可以用 将在父组件中子组件包含的内容引用进来。 This is an Error for Demo Purposes .alert-box { /* ... */ } This is an Error for Demo Purposes Something bad happened. 6 动态组件 有些场景会需要在两个组件间来回切换，比如 Tab 界面： 通过 Vue 的 元素和特殊的 is 属性实现： 被传给 :is 的值可以是以下几种： 被注册的组件名 导入的组件对象 你也可以使用 is 属性来创建一般的 HTML 元素。 当使用 来在多个组件间作切换时，被切换掉的组件会被卸载。我们可以通过 组件强制被切换掉的组件仍然保持“存活”的状态。 7 直接在DOM中写模板 即不是在vue中写？ 如果你想在 DOM 中直接书写 Vue 模板，Vue 则必须从 DOM 中获取模板字符串。由于浏览器的原生 HTML 解析行为限制，有一些需要注意的事项。 请注意下面讨论只适用于直接在 DOM 中编写模板的情况。如果你使用来自以下来源的字符串模板，就不需要顾虑这些限制了： 单文件组件 内联模板字符串 (例如 template: '...') 7.1 大小写区分 HTML 标签和属性名称是不分大小写的，所以浏览器会把任何大写的字符解释为小写。这意味着当你使用 DOM 内的模板时，无论是 PascalCase 形式的组件名称、camelCase 形式的 prop 名称还是 v-on 的事件名称，都需要转换为相应等价的 kebab-case (短横线连字符) 形式： // JavaScript 中的 camelCase const BlogPost = { props: ['postTitle'], emits: ['updatePost'], template: ` ` } 7.2 闭合标签 Vue 的模板解析器支持任意标签使用 /> 作为标签关闭的标志： 然而在 DOM 模板中，我们必须显式地写出关闭标签： 7.3 元素位置限制 某些元素仅在放置于特定元素中时才会显示，例如 ， 和 。 这将导致在使用带有此类限制元素的组件时出现问题。例如： 自定义的组件 将作为无效的内容被忽略，因而在最终呈现的输出中造成错误。我们可以使用特殊的 is 属性作为一种解决方案： 当使用在原生 HTML 元素上时，is 的值必须加上前缀 vue: 才可以被解析为一个 Vue 组件。这一点是必要的，为了避免和原生的自定义内置元素相混淆。 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-08-18 21:02:19 "}}