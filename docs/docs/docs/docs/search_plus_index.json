{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction https://staging-cn.vuejs.org/guide Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-08-08 18:44:32 "},"chapter1/":{"url":"chapter1/","title":"1 vue3入门","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 示例 1 俩特点 2 组件 3 单文件组件 4 组件书写风格 4.1 组合式 API 4.2 选项式 API 4.3 如何选用 5 quick start vue3入门 示例 test.vue export default { data() { return { count: 0 } } } Count is: button { font-weight: bold; } 1 俩特点 声明式渲染：Vue 基于标准 HTML 拓展了一套模板语法，使得我们可以声明式地描述最终输出的 HTML 和 JavaScript 状态之间的关系。 就是说：把各部分要用到的功能描述了一遍，由底层框架去调用程序员声明的功能实现来运行程序。 响应性：Vue 会自动跟踪 JavaScript 状态变化并在改变发生时响应式地更新 DOM。 说白了，一些定义的变量产生变化，就自动刷新局部页面。 2 组件 和react中的概念类似，这里写好这里可以用，也可以被其他地方导入，在其他地方使用。 3 单文件组件 使用一种类似 HTML 格式的文件来书写 Vue 组件，它被称为单文件组件 (也被称为 *.vue 文件，英文 Single-File Components，缩写为 SFC)。 说白了，Vue 的单文件组件(一个文件中) = 逻辑 (JavaScript) + 模板 (HTML) + 和样式 (CSS) 4 组件书写风格 4.1 组合式 API setup是一个标识，告诉 Vue 需要在编译时进行一些处理，让我们可以更简洁地使用组合式 API。比如， 中的导入和顶层变量/函数都能够在中直接使用。 import { ref, onMounted } from 'vue' // 响应式状态 const count = ref(0) // 用来修改状态、触发更新的函数 function increment() { count.value++ } // 生命周期钩子 onMounted(() => { console.log(`The initial count is ${count.value}.`) }) Count is: 4.2 选项式 API 类似面向对象语言，选项式 API 以“组件实例”的概念为中心 (即例子中的 this指向当前的组件实例)，基于组合式 API 的基础上实现。 export default { // data() 返回的属性将会成为响应式的状态 // 并且暴露在 `this` 上 data() { return { count: 0 } }, // methods 是一些用来更改状态与触发更新的函数 // 它们可以在模板中作为事件监听器绑定 methods: { increment() { this.count++ } }, // 生命周期钩子会在组件生命周期的各个不同阶段被调用 // 例如这个函数就会在组件挂载完成后被调用 mounted() { console.log(`The initial count is ${this.count}.`) } } Count is: 4.3 如何选用 当你不需要使用构建工具，或者打算主要在低复杂度的场景中使用 Vue，例如渐进增强的应用场景，推荐采用选项式 API。 当你打算用 Vue 构建完整的单页应用，推荐采用组合式 API + 单文件组件。 5 quick start 注意：在本地用vite构建vue项目时，使用npm init vue@latest会在当前目录创建你的项目，因此选好目录再使用该命令最好。 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-08-08 20:09:45 "},"chapter2/section1/":{"url":"chapter2/section1/","title":"2.1 创建一个 Vue 应用","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 应用实例 1.1 传入参数 2 根组件实例 2.1 传入参数 3 应用配置 4 多个应用实例 创建一个 Vue 应用 1 应用实例 createApp返回一个应用实例。 import { createApp } from 'vue' const app = createApp({ /* 根组件选项 */ }) 1.1 传入参数 传入的参数称之为这个应用实例的根组件， import { createApp } from 'vue' // 从一个单文件组件中导入根组件 import App from './App.vue' const app = createApp(App) 而在这个根组件内部import到的其他组件称之为子组件，如下： App (root component) ├─ TodoList │ └─ TodoItem │ ├─ TodoDeleteButton │ └─ TodoEditButton └─ TodoFooter ├─ TodoClearButton └─ TodoStatistics 2 根组件实例 应用实例通过调用 .mount() 方法后才被渲染出来，返回的称为根组件实例。 2.1 传入参数 传入参数称为容器，可以是： 一个实际的 DOM 元素 (标签) 或一个 CSS 选择器字符串 (id/class) app.mount('#app') createApp传入的根组件的内容将会被渲染在容器元素里面。而容器元素自己将不会被视为应用的一部分。 当在未采用构建流程的情况下使用 Vue 时，我们可以在挂载容器中直接书写根组件模板： import { createApp } from 'vue' const app = createApp({ data() { return { count: 0 } } }) app.mount('#app') 当根组件没有设置 template 选项时，Vue 将自动使用容器的 innerHTML 作为模板。 .mount() 方法应该始终在整个应用配置和资源注册(见3 应用配置)完成后被调用。 3 应用配置 应用实例会暴露一个 .config 对象允许我们配置一些应用级的选项，例如定义一个应用级的错误处理器，它将捕获所有由子组件上抛而未被处理的错误： app.config.errorHandler = (err) => { /* 处理错误 */ } 应用实例还提供了一些方法来注册应用范围内可用的资源，例如注册一个组件： app.component('TodoDeleteButton', TodoDeleteButton) 这使得 TodoDeleteButton 在应用的任何地方都是可用的。 4 多个应用实例 应用实例并不只限于一个。createApp API 允许你在同一个页面中创建多个共存的 Vue 应用，而且每个应用都拥有自己的用于配置和全局资源的作用域。 const app1 = createApp({ /* ... */ }) app1.mount('#container-1') const app2 = createApp({ /* ... */ }) app2.mount('#container-2') 如果你正在使用 Vue 来增强服务端渲染 HTML，并且只想要 Vue 去控制一个大型页面中特殊的一小部分，应避免将一个单独的 Vue 应用实例挂载到整个页面上，而是应该创建多个小的应用实例，将它们分别挂载到所需的元素上去。 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-08-08 20:51:33 "},"chapter2/section2/":{"url":"chapter2/section2/","title":"2.2 vue中的js表达式","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 往html中插值 2 JavaScript 表达式的使用场景 2.1 表达式使用限制 3 vue指令 3.1 动态参数 3.1.1 值限制 3.1.2 语法限制 4 修饰符 5 完整指令格式 vue中的js表达式 1 往html中插值 rawHtml = 'This should be red.' 1 插入文本：两个花括号之间本没有空格，因为gitbook的原因所以空的 Using text interpolation: { { rawHtml } } 会被替换为 Using text interpolation: This should be red. 2 插入html，使用v-html属性： 会被替换为 This should be red. 3 映射标签的属性id到自定义的字段dynamicId上： 若dynamicId为null 或 undefined，属性id将会从渲染的元素上移除， 可简写为： 4 映射标签的布尔属性disabled到自定义的字段isButtonDisabled上： Button 当 isButtonDisabled 为真值或一个空字符串 (即 ) 时，元素会包含这个 disabled attribute。 而当其为其他假值时 attribute 将被忽略。 5 映射JavaScript 对象到标签的属性上 data() { return { objectOfAttrs: { id: 'container', class: 'wrapper' } } } 2 JavaScript 表达式的使用场景 在Vue 模板内，可以在： 在文本插值中 【双大括号内】 在任何 Vue 指令 (以 v- 开头的特殊属性) 的值中【v-**=\"值\"】 { { number + 1 } } { { ok ? 'YES' : 'NO' } } { { message.split('').reverse().join('') } } 2.1 表达式使用限制 一、单一表达式 每个绑定仅支持单一表达式，判断方法：是否可以合法地写在 return 后面。 因此表达式也可写成调用其他组件暴露的方法： { { formatDate(date) } } 绑定在表达式中的方法在组件每次更新时都会被重新调用，因此不应该产生任何副作用，比如改变数据或触发异步操作。 二、全局对象 表达式将被沙盒化，仅能够访问到有限的全局对象列表。该列表中会暴露常用的内置全局对象，比如 Math 和 Date。 而用户附加在 window 上的属性没有显式包含在列表中的全局对象将不能在模板内表达式中，只有在 app.config.globalProperties 上显式地添加，才能访问到。 3 vue指令 指令通常期待一个表达式，任务是在其表达式的值变化时响应式地更新 DOM。 v-for、v-on 和 v-slot则不期待表达式 1 v-if 指令会基于表达式 seen 的值的真假来移除/插入该 元素。 Now you see me 2 v-on监听 DOM 事件 ... 可简写为： ... 3.1 动态参数 指令的参数，写在方括号内，可使用js表达式 ... 可简写为： 通过计算，eventName = \"click\",即当点击时，会调用doSomething() 3.1.1 值限制 动态参数中表达式的值应当是一个字符串，或者是 null。特殊值 null 意为显式移除该绑定。其他非字符串的值会触发警告。 3.1.2 语法限制 一、空格和引号 两者在 HTML 标签的属性名称中都是不合法的。 因此 ... ，即使'foo' + bar的结果是一个合法的字符串，但因为空格和单引号的存在都会产生警告，可用计算属性替换复杂的表达式。 二、大写 如果你的组件拥有 “someAttr” 属性： const someAttr = 'ddd'; 且表达式写为： ... 浏览器会强制将表达式的someAttr替换为 someattr(全部转小写)，最后这段代码将不会工作。 而单文件组件内的模板不受此限制。 4 修饰符 以点开头的特殊后缀，如 .prevent 修饰符会告知 v-on 指令对触发的事件调用 event.preventDefault()： ... 5 完整指令格式 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-08-12 17:22:36 "},"chapter2/section3/":{"url":"chapter2/section3/","title":"2.3 如何使页面动态变化","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 声明状态变量 1.1 注意 2 声明方法 3 DOM 更新时机 4 默认深层响应式 5 调用某个函数（而这个函数自身内部有状态） 如何使页面动态变化 响应式状态：当一个变量通过计算发生值的变化时称为状态的变化，并且页面引用该值的位置会及时得到响应进行改变。 1 声明状态变量 选用选项式 API 时，会用 data 选项来声明组件的响应式状态。 data() {}, 此选项的值应为返回一个对象的函数。 data() { return 函数【该函数返回一个对象】 }, Vue 将在创建新组件实例的时候调用此函数，并将函数返回的对象用响应式系统进行包装。此对象的所有顶层属性都会被代理到组件实例 (即方法和生命周期钩子中的 this) 上。如下： export default { data() { return { //直接返回对象也行 count: 1 } }, // `mounted` 是生命周期钩子，之后我们会讲到 mounted() { // `this` 指向当前组件实例 console.log(this.count) // => 1 // 数据属性也可以被更改 this.count = 2 } } 这些实例上的属性仅在实例首次创建时被添加，若所需的值还未准备好，在必要时也可以使用 null、undefined 或者其他一些值占位。 不在 data 上定义的组件实例后添加的新属性将无法触发响应式更新。 状态变量中不能使用 $ 或 _ 因为Vue 在组件实例上暴露的内置 API 使用 $ 作为前缀。它同时也为内部属性保留 _ 前缀。 1.1 注意 状态变量基于js代理实现响应式。 说白了，这些所谓的状态变量会被js监控，值变了就通过js修改，页面中的值自然会发生变化。 export default { data() { return { someObject: {} } }, mounted() { const newObject = {} this.someObject = newObject //两者值一样，但someObject还是状态变量，newObject只是个普通 console.log(newObject === this.someObject) // false } } 2 声明方法 methods 选项是一个包含所有方法的对象： export default { data() { return { count: 0 } }, methods: { increment() { this.count++ }, { // 反例：箭头函数无法访问此处的 `this`! } --> }, mounted() { // 在其他方法或是生命周期中也可以调用方法 this.increment() } } Vue 自动为 methods 中的方法绑定了永远指向组件实例的 this。这确保了方法在作为事件监听器或回调函数时始终保持正确的 this。不应该在定义 methods 时使用箭头函数，因为箭头函数没有自己的 this 上下文。 和组件实例上的其他属性一样，方法也可以在模板上被访问。在模板中它们常常被用作事件监听器： 3 DOM 更新时机 当你更改响应式状态后，DOM 也会自动更新。然而，你得注意 DOM 的更新并不是同步的。相反，Vue 将缓冲它们直到更新周期的 “下个时机” 以确保无论你进行了多少次声明更改，每个组件都只需要更新一次。 可以使用 nextTick() 这个全局 API访问到状态改变后的 DOM： import { nextTick } from 'vue' export default { methods: { increment() { this.count++ nextTick(() => { // 访问更新后的 DOM }) } } } 4 默认深层响应式 即使在更改深层次的对象或数组，改动也能被检测到。 export default { data() { return { obj: { nested: { count: 0 }, arr: ['foo', 'bar'] } } }, methods: { mutateDeeply() { // 以下都会按照期望工作 this.obj.nested.count++ this.obj.arr.push('baz') } } } 也可以直接创建一个浅层响应式对象。它们仅在顶层具有响应性，一般仅在某些特殊场景中需要。 5 调用某个函数（而这个函数自身内部有状态） 在某些情况下，我们可能需要动态地创建一个方法函数，比如创建一个预置防抖的事件处理器： import { debounce } from 'lodash-es' export default { methods: { // 使用 Lodash 的防抖函数 click: debounce(function () { // ... 对点击的响应 ... }, 500) } } 不过这种方法对于被重用的组件来说是有问题的，因为这个预置防抖的函数是 有状态的：它在运行时维护着一个内部状态。如果多个组件实例都共享这同一个预置防抖的函数，那么它们之间将会互相影响。 要保持每个组件实例的防抖函数都彼此独立，我们可以改为在 created 生命周期钩子中创建这个预置防抖的函数： export default { created() { // 每个实例都有了自己的预置防抖的处理函数 this.debouncedClick = _.debounce(this.click, 500) }, unmounted() { // 最好是在组件卸载时 // 清除掉防抖计时器 this.debouncedClick.cancel() }, methods: { click() { // ... 对点击的响应 ... } } } Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-08-10 17:58:38 "},"chapter2/section4/":{"url":"chapter2/section4/","title":"2.4 可重用的计算","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 computed 2 computed vs methods 3 更改计算属性 4 注意 可重用的计算 1 computed export default { data() { return { author: { name: 'John Doe', books: [ 'Vue 2 - Advanced Guide', 'Vue 3 - Basic Guide', 'Vue 4 - The Mystery' ] } } } } { { author.books.length > 0 ? 'Yes' : 'No' } } 如果在模板中需要不止一次这样的计算，便显得代码臃肿。 推荐使用计算属性computed来描述依赖响应式状态的复杂逻辑 export default { data() { return { author: { name: 'John Doe', books: [ 'Vue 2 - Advanced Guide', 'Vue 3 - Basic Guide', 'Vue 4 - The Mystery' ] } } }, computed: { // 一个计算属性的 getter publishedBooksMessage() { // `this` 指向当前组件实例 return this.author.books.length > 0 ? 'Yes' : 'No' } } } { { publishedBooksMessage } } Vue 会检测到 this.publishedBooksMessage 依赖于 this.author.books， 所以当 this.author.books 改变时，任何依赖于 this.publishedBooksMessage 的绑定都将同时更新。 2 computed vs methods // 组件中 methods: { calculateBooksMessage() { return this.author.books.length > 0 ? 'Yes' : 'No' } } { { calculateBooksMessage() } } 两者的不同之处在于计算属性值会基于其响应式依赖被缓存。 一个计算属性仅会在其响应式依赖更新时才重新计算。这意味着只要 author.books 不改变，无论多少次访问 publishedBooksMessage 都会立即返回先前的计算结果，而不用重复执行 getter 函数。 错误使用案例 computed: { now() { return Date.now() //Date.now() 并不是一个响应式依赖，因此计算属性now永远不会更新 } } 3 更改计算属性 在外部手动修改计算属性，而不是通过计算函数得出结果，必须得重写getter、setter方法： export default { data() { return { firstName: 'John', lastName: 'Doe' } }, computed: { fullName: { // getter get() { return this.firstName + ' ' + this.lastName }, // setter set(newValue) { // 注意：我们这里使用的是解构赋值语法 [this.firstName, this.lastName] = newValue.split(' ') } } } } this.fullName = 'John Doe' //修改成功，因为setter调用时，实际上还是改的状态变量，从而导致依赖它两个的计算变量得到更新。 总的来说，虽然可以更改，但其实没有必要。 4 注意 不要在计算函数中产生异步请求或者更改 DOM等副作用，有专门讲的监听器：根据其他响应式状态的变更来主动创建副作用。 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-08-11 17:40:05 "},"chapter2/section5/":{"url":"chapter2/section5/","title":"2.5 v-bind的特殊增强","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 针对class 1.1 与class并存 1.2 引用对象 1.3 引用计算属性（常用） 1.4 引用数组 1.5 在组件上使用class的情况 1.5.1 一个根节点 1.5.1 多个根节点 2 针对style 2.1 引用对象（常用） 2.2 引用计算属性 2.3 引用数组 2.4 自动前缀 2.5 样式多值 v-bind的特殊增强 Vue 专门为 class 和 style 的 v-bind 用法提供了特殊的功能增强：除了字符串外，表达式的值也可以是对象或数组。 1 针对class 给v-bind:class传递一个对象，判断是否class=\"active\"： 可见active是否出现，要依赖于状态变量isActive的值。 1.1 与class并存 由于class的值可以同时有多个，因此vue也支持和一般的 class属性共存。 data() { return { isActive: true, hasError: false } } 渲染后便是： //因为hasError为false，所以text-danger没出现 1.2 引用对象 data() { return { classObject: { active: true, 'text-danger': false } } } 结果一样。 1.3 引用计算属性（常用） data() { return { isActive: true, error: null } }, computed: { classObject() { return { active: this.isActive && !this.error, 'text-danger': this.error && this.error.type === 'fatal' } } } 1.4 引用数组 data() { return { activeClass: 'active', errorClass: 'text-danger' } } 渲染后是： 还可以使用三目表达式： 可以直接换成： 1.5 在组件上使用class的情况 一个组件被写好后，通常会被其它组件import后进行使用，那么在被外部使用时会出现两种情况： 组件内部只有一个根节点 组件内部有多个根节点 1.5.1 一个根节点 声明了一个组件名叫 MyComponent，内部实现的template如下： Hi! 被外部使用时添加一些 class： 此时这个class的值只会被绑定到唯一的根节点上： Hi 1.5.1 多个根节点 在实现内部使用$attrs获得上层传入的属性，然后根据情况选择在何处使用： Hi! This is a child component 被外部使用时添加一些 class： 此时这个class的值传到内部后： Hi! This is a child component 2 针对style data() { return { activeColor: 'red', fontSize: 30 } } CSS的字段支持： 驼峰法（camelCase）【推荐使用】 短横线隔开式 （kebab-cased）【对应其 CSS 中的实际名称】 2.1 引用对象（常用） data() { return { styleObject: { color: 'red', fontSize: '13px' } } } 2.2 引用计算属性 2.3 引用数组 2.4 自动前缀 当你在 :style 中使用了需要浏览器特殊前缀的 CSS 属性时，Vue 会自动为他们加上相应的前缀。Vue 是在运行时检查该属性是否支持在当前浏览器中使用。如果浏览器不支持某个属性，那么将测试加上各个浏览器特殊前缀，以找到哪一个是被支持的。 2.5 样式多值 你可以对一个样式属性提供多个 (不同前缀的) 值，举例来说： 数组仅会渲染浏览器支持的最后一个值。在这个示例中，在支持不需要特别前缀的浏览器中都会渲染为 display: flex。 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-08-12 18:19:18 "},"chapter2/section6/":{"url":"chapter2/section6/","title":"2.6 v-if介绍","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 v-if · v-else-if · v-else 1.1 上的 v-if 2 v-show 3 v-if vs v-show 4 v-if 和 v-for vue的逻辑处理 1 v-if · v-else-if · v-else 元素必须在同级，并且是紧跟上一元素。 这三个在只有当条件为true时，才会渲染元素，也就是dom上才会有这个元素，否则就没有。 Toggle Toggle A B C Not A/B/C 1.1 上的 v-if 因为 v-if 是一个指令，他必须依附于某个元素。但如果我们想要切换不止一个元素呢？在这种情况下我们可以在一个 元素上使用 v-if，这只是一个不可见的包装器元素，最后渲染的结果并不会包含这个 元素。 Title Paragraph 1 Paragraph 2 v-else 和 v-else-if 也可以在 上使用。 思考：可否像这样： Title Paragraph 1 Paragraph 2 2 v-show v-show 仅切换了该元素上名为 display 的 CSS 属性，并且会在 DOM 渲染中保留该元素。 v-show 不支持在 元素上使用，也不能和 v-else 搭配使用。 Hello! 3 v-if vs v-show v-if 是惰性的：如果在初次渲染时条件值为 false，则不会做任何事。条件区块只有当条件首次变为 true 时才被渲染。 v-if 是“真实的”按条件渲染，因为它确保了在切换时，条件区块内的事件监听器和子组件都会被销毁与重建。 v-show 简单许多，元素无论初始条件如何，始终会被渲染，只有 CSS display 属性会被切换。 总的来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要频繁切换，则使用 v-show 较好；如果在运行时绑定条件很少改变，则 v-if 会更合适。 4 v-if 和 v-for 当 v-if 和 v-for 同时存在于一个元素上的时候，v-if 会首先被执行。 同时使用 v-if 和 v-for 是不推荐的，因为这样二者的优先级不明显。 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-08-14 17:33:23 "},"chapter2/section7/":{"url":"chapter2/section7/","title":"2.6 v-for介绍","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 遍历数组 1.1 js模拟vue的实现效果 1.2 遍历时使用解构 1.3 of 替代 in 2 遍历对象 3 v-for的循环次数 4 上的 v-for 5 v-for 与 v-if 6 v-for渲染后又发生更新 7 组件上使用 v-for 7.1 渲染结果 8 数组变化时的渲染 8.1 变更方法 8.2 非变更方法 8.3 利用计算属性 v-for介绍 1 遍历数组 data() { return { parentMessage: 'Parent', items: [{ message: 'Foo' }, { message: 'Bar' }] } } //当前项的位置索引index参数为可选参数 { { parentMessage } } - { { index } } - { { item.message } } 渲染后： Parent - 0 - Foo Parent - 1 - Bar 1.1 js模拟vue的实现效果 const parentMessage = 'Parent' const items = [ /* ... */ ] items.forEach((item, index) => { // 可以访问外层的 `parentMessage` // 而 `item` 和 `index` 只在这个作用域可用 console.log(parentMessage, item.message, index) }) 1.2 遍历时使用解构 //从对象里解构出字段 { { message } } { { message } } { { index } } 1.3 of 替代 in JavaScript 的迭代器语法用 of 2 遍历对象 export default { data() { return { myObject: { title: 'How to do lists in Vue', author: 'Jane Doe', publishedAt: '2016-04-10' } } } } { { index } }. { { key } }: { { value } } 渲染后： 0. title: How to do lists in Vue 1. author: Jane Doe 2. publishedAt: 2016-04-10 3 v-for的循环次数 { { n } } 注意此处 n 的初值是从 1 开始而非 0，即n = [1,10]。 4 上的 v-for 与模板上的 v-if 类似，你也可以在 标签上使用 v-for 来渲染一个包含多个元素的块。例如： { { item.msg } } 5 v-for 与 v-if 在上一section的最后一个小节讲过， 当它们同时存在于一个节点上时，v-if 比 v-for 的优先级更高。这意味着 v-if 的条件将无法访问到 v-for 作用域内定义的变量别名： { { todo.name } } 在外新包装一层 再在其上使用 v-for 可以解决这个问题 (这也更加明显易读)： { { todo.name } } 6 v-for渲染后又发生更新 v-for 渲染的元素列表更新的默认模式为：当数据项的顺序改变时，Vue 不会随之移动 DOM 元素的顺序，而是就地更新每个元素内的值，但只适用于列表渲染输出的结果不依赖子组件状态或者临时 DOM 状态 (例如表单输入值) 的情况。 上面仅供了解，如果发生需要移动dom元素的场景，我们使用v-for，通常需要绑定一个key跟踪每个节点的标识： //使用的v-bind:key 当你使用 时，key 应该被放置在这个 容器上： { { todo.name } } key 绑定的值期望是一个基础类型的值，例如字符串或 number 类型。不要用对象作为 v-for 的 key。 7 组件上使用 v-for import TodoItem from './TodoItem.vue' export default { components: { TodoItem }, data() { return { todos: [ { id: 1, title: 'Do the dishes' }, { id: 2, title: 'Take out the trash' }, { id: 3, title: 'Mow the lawn' } ], } } } 下面是TodoItem.vue export default { props: ['title'], } { { title } } 7.1 渲染结果 Do the dishes Take out the trash Mow the lawn 8 数组变化时的渲染 8.1 变更方法 对原数组进行修改。 push() pop() shift() unshift() splice() sort() reverse() 8.2 非变更方法 原数组不变，返回一个新数组。 filter() concat() slice() 例： this.items = this.items.filter((item) => item.message.match(/Foo/)) 8.3 利用计算属性 有时，我们希望显示数组经过过滤或排序后的内容，而不实际变更或重置原始数据。 data() { return { sets: [[ 1, 2, 3, 4, 5 ], [6, 7, 8, 9, 10]] } }, methods: { even(numbers) { return numbers.filter(number => number % 2 === 0) } } { { n } } 在计算属性中使用 reverse() 和 sort() 的时候务必小心！这两个方法将变更原始数组，计算函数中不应该这么做。请在调用这些方法之前创建一个原数组的副本： //return numbers.reverse() return [...numbers].reverse() Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-08-14 18:25:18 "}}