{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction https://staging-cn.vuejs.org/guide Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-08-08 18:44:32 "},"chapter1/":{"url":"chapter1/","title":"1 vue3入门","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 示例 1 俩特点 2 组件 3 单文件组件 4 组件书写风格 4.1 组合式 API 4.2 选项式 API 4.3 如何选用 5 quick start vue3入门 示例 test.vue export default { data() { return { count: 0 } } } Count is: button { font-weight: bold; } 1 俩特点 声明式渲染：Vue 基于标准 HTML 拓展了一套模板语法，使得我们可以声明式地描述最终输出的 HTML 和 JavaScript 状态之间的关系。 就是说：把各部分要用到的功能描述了一遍，由底层框架去调用程序员声明的功能实现来运行程序。 响应性：Vue 会自动跟踪 JavaScript 状态变化并在改变发生时响应式地更新 DOM。 说白了，一些定义的变量产生变化，就自动刷新局部页面。 2 组件 和react中的概念类似，这里写好这里可以用，也可以被其他地方导入，在其他地方使用。 3 单文件组件 使用一种类似 HTML 格式的文件来书写 Vue 组件，它被称为单文件组件 (也被称为 *.vue 文件，英文 Single-File Components，缩写为 SFC)。 说白了，Vue 的单文件组件(一个文件中) = 逻辑 (JavaScript) + 模板 (HTML) + 和样式 (CSS) 4 组件书写风格 4.1 组合式 API setup是一个标识，告诉 Vue 需要在编译时进行一些处理，让我们可以更简洁地使用组合式 API。比如， 中的导入和顶层变量/函数都能够在中直接使用。 import { ref, onMounted } from 'vue' // 响应式状态 const count = ref(0) // 用来修改状态、触发更新的函数 function increment() { count.value++ } // 生命周期钩子 onMounted(() => { console.log(`The initial count is ${count.value}.`) }) Count is: 4.2 选项式 API 类似面向对象语言，选项式 API 以“组件实例”的概念为中心 (即例子中的 this指向当前的组件实例)，基于组合式 API 的基础上实现。 export default { // data() 返回的属性将会成为响应式的状态 // 并且暴露在 `this` 上 data() { return { count: 0 } }, // methods 是一些用来更改状态与触发更新的函数 // 它们可以在模板中作为事件监听器绑定 methods: { increment() { this.count++ } }, // 生命周期钩子会在组件生命周期的各个不同阶段被调用 // 例如这个函数就会在组件挂载完成后被调用 mounted() { console.log(`The initial count is ${this.count}.`) } } Count is: 4.3 如何选用 当你不需要使用构建工具，或者打算主要在低复杂度的场景中使用 Vue，例如渐进增强的应用场景，推荐采用选项式 API。 当你打算用 Vue 构建完整的单页应用，推荐采用组合式 API + 单文件组件。 5 quick start 注意：在本地用vite构建vue项目时，使用npm init vue@latest会在当前目录创建你的项目，因此选好目录再使用该命令最好。 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-08-08 20:09:45 "},"chapter2/section1/":{"url":"chapter2/section1/","title":"2.1 创建一个 Vue 应用","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 应用实例 1.1 传入参数 2 根组件实例 2.1 传入参数 3 应用配置 4 多个应用实例 创建一个 Vue 应用 1 应用实例 createApp返回一个应用实例。 import { createApp } from 'vue' const app = createApp({ /* 根组件选项 */ }) 1.1 传入参数 传入的参数称之为这个应用实例的根组件， import { createApp } from 'vue' // 从一个单文件组件中导入根组件 import App from './App.vue' const app = createApp(App) 而在这个根组件内部import到的其他组件称之为子组件，如下： App (root component) ├─ TodoList │ └─ TodoItem │ ├─ TodoDeleteButton │ └─ TodoEditButton └─ TodoFooter ├─ TodoClearButton └─ TodoStatistics 2 根组件实例 应用实例通过调用 .mount() 方法后才被渲染出来，返回的称为根组件实例。 2.1 传入参数 传入参数称为容器，可以是： 一个实际的 DOM 元素 (标签) 或一个 CSS 选择器字符串 (id/class) app.mount('#app') createApp传入的根组件的内容将会被渲染在容器元素里面。而容器元素自己将不会被视为应用的一部分。 当在未采用构建流程的情况下使用 Vue 时，我们可以在挂载容器中直接书写根组件模板： import { createApp } from 'vue' const app = createApp({ data() { return { count: 0 } } }) app.mount('#app') 当根组件没有设置 template 选项时，Vue 将自动使用容器的 innerHTML 作为模板。 .mount() 方法应该始终在整个应用配置和资源注册(见3 应用配置)完成后被调用。 3 应用配置 应用实例会暴露一个 .config 对象允许我们配置一些应用级的选项，例如定义一个应用级的错误处理器，它将捕获所有由子组件上抛而未被处理的错误： app.config.errorHandler = (err) => { /* 处理错误 */ } 应用实例还提供了一些方法来注册应用范围内可用的资源，例如注册一个组件： app.component('TodoDeleteButton', TodoDeleteButton) 这使得 TodoDeleteButton 在应用的任何地方都是可用的。 4 多个应用实例 应用实例并不只限于一个。createApp API 允许你在同一个页面中创建多个共存的 Vue 应用，而且每个应用都拥有自己的用于配置和全局资源的作用域。 const app1 = createApp({ /* ... */ }) app1.mount('#container-1') const app2 = createApp({ /* ... */ }) app2.mount('#container-2') 如果你正在使用 Vue 来增强服务端渲染 HTML，并且只想要 Vue 去控制一个大型页面中特殊的一小部分，应避免将一个单独的 Vue 应用实例挂载到整个页面上，而是应该创建多个小的应用实例，将它们分别挂载到所需的元素上去。 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-08-08 20:51:33 "}}