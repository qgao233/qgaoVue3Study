{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction https://staging-cn.vuejs.org/guide Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-08-08 18:44:32 "},"chapter1/":{"url":"chapter1/","title":"1 vue3入门","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 示例 1 俩特点 2 组件 3 单文件组件 4 组件书写风格 4.1 组合式 API 4.2 选项式 API 4.3 如何选用 5 quick start vue3入门 示例 test.vue export default { data() { return { count: 0 } } } Count is: button { font-weight: bold; } 1 俩特点 声明式渲染：Vue 基于标准 HTML 拓展了一套模板语法，使得我们可以声明式地描述最终输出的 HTML 和 JavaScript 状态之间的关系。 就是说：把各部分要用到的功能描述了一遍，由底层框架去调用程序员声明的功能实现来运行程序。 响应性：Vue 会自动跟踪 JavaScript 状态变化并在改变发生时响应式地更新 DOM。 说白了，一些定义的变量产生变化，就自动刷新局部页面。 2 组件 和react中的概念类似，这里写好这里可以用，也可以被其他地方导入，在其他地方使用。 3 单文件组件 使用一种类似 HTML 格式的文件来书写 Vue 组件，它被称为单文件组件 (也被称为 *.vue 文件，英文 Single-File Components，缩写为 SFC)。 说白了，Vue 的单文件组件(一个文件中) = 逻辑 (JavaScript) + 模板 (HTML) + 和样式 (CSS) 4 组件书写风格 4.1 组合式 API setup是一个标识，告诉 Vue 需要在编译时进行一些处理，让我们可以更简洁地使用组合式 API。比如， 中的导入和顶层变量/函数都能够在中直接使用。 import { ref, onMounted } from 'vue' // 响应式状态 const count = ref(0) // 用来修改状态、触发更新的函数 function increment() { count.value++ } // 生命周期钩子 onMounted(() => { console.log(`The initial count is ${count.value}.`) }) Count is: 4.2 选项式 API 类似面向对象语言，选项式 API 以“组件实例”的概念为中心 (即例子中的 this指向当前的组件实例)，基于组合式 API 的基础上实现。 export default { // data() 返回的属性将会成为响应式的状态 // 并且暴露在 `this` 上 data() { return { count: 0 } }, // methods 是一些用来更改状态与触发更新的函数 // 它们可以在模板中作为事件监听器绑定 methods: { increment() { this.count++ } }, // 生命周期钩子会在组件生命周期的各个不同阶段被调用 // 例如这个函数就会在组件挂载完成后被调用 mounted() { console.log(`The initial count is ${this.count}.`) } } Count is: 4.3 如何选用 当你不需要使用构建工具，或者打算主要在低复杂度的场景中使用 Vue，例如渐进增强的应用场景，推荐采用选项式 API。 当你打算用 Vue 构建完整的单页应用，推荐采用组合式 API + 单文件组件。 5 quick start 注意：在本地用vite构建vue项目时，使用npm init vue@latest会在当前目录创建你的项目，因此选好目录再使用该命令最好。 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-08-08 20:09:45 "},"chapter2/section1/":{"url":"chapter2/section1/","title":"2.1 创建一个 Vue 应用","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 应用实例 1.1 传入参数 2 根组件实例 2.1 传入参数 3 应用配置 4 多个应用实例 创建一个 Vue 应用 1 应用实例 createApp返回一个应用实例。 import { createApp } from 'vue' const app = createApp({ /* 根组件选项 */ }) 1.1 传入参数 传入的参数称之为这个应用实例的根组件， import { createApp } from 'vue' // 从一个单文件组件中导入根组件 import App from './App.vue' const app = createApp(App) 而在这个根组件内部import到的其他组件称之为子组件，如下： App (root component) ├─ TodoList │ └─ TodoItem │ ├─ TodoDeleteButton │ └─ TodoEditButton └─ TodoFooter ├─ TodoClearButton └─ TodoStatistics 2 根组件实例 应用实例通过调用 .mount() 方法后才被渲染出来，返回的称为根组件实例。 2.1 传入参数 传入参数称为容器，可以是： 一个实际的 DOM 元素 (标签) 或一个 CSS 选择器字符串 (id/class) app.mount('#app') createApp传入的根组件的内容将会被渲染在容器元素里面。而容器元素自己将不会被视为应用的一部分。 当在未采用构建流程的情况下使用 Vue 时，我们可以在挂载容器中直接书写根组件模板： import { createApp } from 'vue' const app = createApp({ data() { return { count: 0 } } }) app.mount('#app') 当根组件没有设置 template 选项时，Vue 将自动使用容器的 innerHTML 作为模板。 .mount() 方法应该始终在整个应用配置和资源注册(见3 应用配置)完成后被调用。 3 应用配置 应用实例会暴露一个 .config 对象允许我们配置一些应用级的选项，例如定义一个应用级的错误处理器，它将捕获所有由子组件上抛而未被处理的错误： app.config.errorHandler = (err) => { /* 处理错误 */ } 应用实例还提供了一些方法来注册应用范围内可用的资源，例如注册一个组件： app.component('TodoDeleteButton', TodoDeleteButton) 这使得 TodoDeleteButton 在应用的任何地方都是可用的。 4 多个应用实例 应用实例并不只限于一个。createApp API 允许你在同一个页面中创建多个共存的 Vue 应用，而且每个应用都拥有自己的用于配置和全局资源的作用域。 const app1 = createApp({ /* ... */ }) app1.mount('#container-1') const app2 = createApp({ /* ... */ }) app2.mount('#container-2') 如果你正在使用 Vue 来增强服务端渲染 HTML，并且只想要 Vue 去控制一个大型页面中特殊的一小部分，应避免将一个单独的 Vue 应用实例挂载到整个页面上，而是应该创建多个小的应用实例，将它们分别挂载到所需的元素上去。 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-08-08 20:51:33 "},"chapter2/section2/":{"url":"chapter2/section2/","title":"2.2 vue中的js表达式","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 往html中插值 2 JavaScript 表达式的使用场景 2.1 表达式使用限制 3 vue指令 3.1 动态参数 3.1.1 值限制 3.1.2 语法限制 4 修饰符 5 完整指令格式 vue中的js表达式 1 往html中插值 rawHtml = 'This should be red.' 1 插入文本：两个花括号之间本没有空格，因为gitbook的原因所以空的 Using text interpolation: { { rawHtml } } 会被替换为 Using text interpolation: This should be red. 2 插入html，使用v-html属性： 会被替换为 This should be red. 3 映射标签的属性id到自定义的字段dynamicId上： 若dynamicId为null 或 undefined，属性id将会从渲染的元素上移除， 可简写为： 4 映射标签的布尔属性disabled到自定义的字段isButtonDisabled上： Button 当 isButtonDisabled 为真值或一个空字符串 (即 ) 时，元素会包含这个 disabled attribute。 而当其为其他假值时 attribute 将被忽略。 5 映射JavaScript 对象到标签的属性上 data() { return { objectOfAttrs: { id: 'container', class: 'wrapper' } } } 2 JavaScript 表达式的使用场景 在Vue 模板内，可以在： 在文本插值中 【双大括号内】 在任何 Vue 指令 (以 v- 开头的特殊属性) 的值中【v-**=\"值\"】 { { number + 1 } } { { ok ? 'YES' : 'NO' } } { { message.split('').reverse().join('') } } 2.1 表达式使用限制 一、单一表达式 每个绑定仅支持单一表达式，判断方法：是否可以合法地写在 return 后面。 因此表达式也可写成调用其他组件暴露的方法： { { formatDate(date) } } 绑定在表达式中的方法在组件每次更新时都会被重新调用，因此不应该产生任何副作用，比如改变数据或触发异步操作。 二、全局对象 表达式将被沙盒化，仅能够访问到有限的全局对象列表。该列表中会暴露常用的内置全局对象，比如 Math 和 Date。 而用户附加在 window 上的属性没有显式包含在列表中的全局对象将不能在模板内表达式中，只有在 app.config.globalProperties 上显式地添加，才能访问到。 3 vue指令 指令通常期待一个表达式，任务是在其表达式的值变化时响应式地更新 DOM。 v-for、v-on 和 v-slot则不期待表达式 1 v-if 指令会基于表达式 seen 的值的真假来移除/插入该 元素。 Now you see me 2 v-on监听 DOM 事件 ... 可简写为： ... 3.1 动态参数 指令的参数，写在方括号内，可使用js表达式 ... 可简写为： 通过计算，eventName = \"click\",即当点击时，会调用doSomething() 3.1.1 值限制 动态参数中表达式的值应当是一个字符串，或者是 null。特殊值 null 意为显式移除该绑定。其他非字符串的值会触发警告。 3.1.2 语法限制 一、空格和引号 两者在 HTML 标签的属性名称中都是不合法的。 因此 ... ，即使'foo' + bar的结果是一个合法的字符串，但因为空格和单引号的存在都会产生警告，可用计算属性替换复杂的表达式。 二、大写 如果你的组件拥有 “someAttr” 属性： const someAttr = 'ddd'; 且表达式写为： ... 浏览器会强制将表达式的someAttr替换为 someattr(全部转小写)，最后这段代码将不会工作。 而单文件组件内的模板不受此限制。 4 修饰符 以点开头的特殊后缀，如 .prevent 修饰符会告知 v-on 指令对触发的事件调用 event.preventDefault()： ... 5 完整指令格式 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-08-09 18:32:45 "}}